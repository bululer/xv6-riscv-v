




## Chapter 4
### 4.1 RISC-V trap machinery
&emsp;每个 RISC-V CPU 都有一组控制寄存器，内核会向这些寄存器写入指令，以告诉 CPU 如何处理陷阱，并且内核可以读取这些寄存器来了解已发生的陷阱。完整的 RISC-V 文档包含了详细的信息[3]。riscv.h 文件(位于 kernel/riscv.h)包含了 xv6 使用的相关定义。以下是最重要的寄存器概述：

1.**sstatus** ：用于控制 CPU 的状态和中断使能。它包含有关当前 CPU 状态和中断使能状态的信息。在 xv6 中，内核使用此寄存器来启用和禁用中断。
2.**stevc** ：用于设置中断处理程序的入口点地址。当发生中断时，CPU 跳转到 stvec 中指定的地址以执行中断处理。
3.**sie** ：用于控制外部中断(例如，时钟中断)的使能。内核使用此寄存器来启用或禁用外部中断。
4.**scause** ：包含有关最近一次陷阱或中断的信息，包括陷阱类型和原因。
5.**sepc** ：包含引发陷阱或中断的指令的地址。当陷阱或中断发生时，CPU 将当前指令的地址保存在 sepc 中，以便在中断处理完成后恢复执行。
6.**sscratch**：一个通用寄存器，内核可以用来存储临时数据或上下文信息。
7.**satp**：包含有关页表的信息，用于虚拟内存管理。

&emsp;当需要强制触发陷阱时，RISC-V 硬件对于除了计时器中断之外的所有陷阱类型执行以下操作：

如果陷阱是设备中断，并且 sstatus 寄存器的 SIE 位被清除，那么不执行以下任何操作。

1.通过清除 sstatus 中的 SIE 位来禁用中断。

2.将当前程序计数器 pc 的值复制到 sepc 寄存器。

3.将当前模式(用户模式或监管模式)保存在 sstatus 寄存器的 SPP 位中。

4.设置 scause 寄存器以反映陷阱的原因。

5.将模式设置为监管模式。

6.复制 stvec 寄存器的值到程序计数器 pc。

7.从新的 pc 开始执行。

&emsp;请注意，在陷阱期间，CPU 不会切换到内核页表，不会切换到内核中的堆栈，也不会保存除了程序计数器(pc)以外的任何寄存器。这些任务必须由内核软件来执行。CPU 在陷阱期间执行最小的工作是为了为软件提供灵活性；例如，某些操作系统在某些情况下会省略页表切换以提高陷阱性能。

&emsp;值得思考的是上述列出的步骤中是否有任何可以省略的步骤，以寻求更快的陷阱。虽然在某些情况下可以使用较简单的序列，但通常情况下省略许多步骤可能会带来风险。例如，假设CPU不切换程序计数器。那么来自用户空间的陷阱可能会在仍在运行用户指令的情况下切换到监管模式。这些用户指令可能会破坏用户/内核隔离，例如通过修改 satp 寄存器以指向允许访问物理内存的页表。因此，CPU切换到内核指定的指令地址，即 stvec，非常重要。


### Trap form user space
&emsp;Xv6根据陷阱发生在内核代码还是用户代码中，以不同的方式处理陷阱。下面是用户代码中发生的陷阱处理过程；第4.5节描述了内核代码中的陷阱处理。

&emsp;当用户程序进行系统调用(使用 ecall 指令)、执行非法操作或设备中断时，可能会在用户空间执行时发生陷阱。从用户空间发生陷阱的高级路径是 uservec(位于 kernel/trampoline.S:21)、然后是 usertrap(位于 kernel/trap.c:37)；在返回时，是 usertrapret(位于 kernel/trap.c:90)，然后是 userret(位于 kernel/trampoline.S:101)。

&emsp;xv6陷阱处理设计的一个重要限制是，RISC-V硬件在强制陷阱时不会切换页表。这意味着 stvec 中的陷阱处理程序地址必须在用户页表中具有有效映射，因为这是陷阱处理代码开始执行时生效的页表。此外，xv6的陷阱处理代码需要切换到内核页表；为了能够在切换后继续执行，内核页表还必须对 stvec 指向的处理程序具有映射。

&emsp;xv6通过使用一个跳板页(trampoline page)来满足这些要求。跳板页包含 uservec，这是stvec指向的xv6陷阱处理代码。跳板页在每个进程的页表中都映射到地址 TRAMPOLINE，它位于虚拟地址空间的顶部，以便位于程序用于自身的内存上方。跳板页还在内核页表中的地址 TRAMPOLINE 处进行映射。请参阅图2.3和图3.3。由于跳板页在用户页表中映射，没有 PTE_U 标志，所以陷阱可以以监管模式开始在那里执行。由于跳板页在内核地址空间中的相同地址处进行映射，陷阱处理程序可以在切换到内核页表后继续执行。

### 4.3 Code:celling system calls
&emsp;第2章以initcode.S调用exec系统调用(user/initcode.S:11)结束。让我们看看用户调用是如何传递到内核中exec系统调用的实现的。
&emsp;initcode.S将exec的参数放入寄存器a0和a1中，并将系统调用号放入a7中。系统调用号与syscalls数组中的条目匹配，这是一个函数指针表(kernel/syscall.c:107)。ecall指令会触发陷阱，导致执行uservec、usertrap，然后执行syscall，就像我们之前看到的那样。

syscall(kernel/syscall.c:132)从陷阱帧中的保存的a7中检索系统调用号，并将其用作索引到syscalls中。对于第一个系统调用，a7包含SYS_exec(kernel/syscall.h:8)，从而调用系统调用实现函数sys_exec。

当sys_exec返回时，syscall将其返回值记录在p->trapframe->a0中。由于RISC-V上的C调用约定将返回值放在a0中，这将导致原始的用户空间exec()调用返回该值。系统调用通常返回负数来表示错误，而返回零或正数表示成功。如果系统调用号无效，syscall会打印错误并返回-1。

### 4.4 Code: System call arguments
&emsp;内核中的系统调用实现需要找到用户代码传递的参数。因为用户代码调用系统调用包装函数，所以参数最初位于RISC-V C调用约定中放置它们的寄存器中。内核陷阱代码将用户寄存器保存到当前进程的陷阱帧中，内核代码可以在那里找到它们。内核函数 argint、argaddr 和 argfd 从陷阱帧中检索第 n 个系统调用参数，分别作为整数、指针或文件描述符。它们都调用 argraw 来检索适当的保存的用户寄存器(kernel/syscall.c:34)。

一些系统调用将指针作为参数传递，内核必须使用这些指针来读取或写入用户内存。例如，exec 系统调用将一个指向用户空间字符串参数的指针数组传递给内核。这些指针存在两个挑战。首先，用户程序可能有错误或恶意，可能会向内核传递一个无效的指针或一个旨在欺骗内核访问内核内存而不是用户内存的指针。其次，xv6 内核的页表映射与用户页表映射不同，因此内核无法使用普通指令从用户提供的地址加载或存储数据。

内核实现了一些函数，用于安全地在用户提供的地址之间传输数据。fetchstr 是一个示例(kernel/syscall.c:25)。文件系统调用，如 exec，使用 fetchstr 从用户空间检索字符串文件名参数。fetchstr 调用 copyinstr 来执行实际的工作。

copyinstr(kernel/vm.c:403)从用户页表 pagetable 的虚拟地址 srcva 复制最多 max 字节到 dst 中。由于 pagetable 不是当前页表，copyinstr 使用 walkaddr(调用 walk)来在 pagetable 中查找 srcva，得到物理地址 pa0。内核将每个物理RAM地址映射到相应的内核虚拟地址，因此 copyinstr 可以直接从 pa0 复制字符串字节到 dst。walkaddr(kernel/vm.c:109)检查用户提供的虚拟地址是否属于进程的用户地址空间，因此程序无法欺骗内核读取其他内存。类似的函数 copyout 用于将数据从内核复制到用户提供的地址。

### 4.5  Trap from kernel spaces
&emsp;Xv6在配置CPU陷阱寄存器时，根据正在执行的是用户代码还是内核代码，会稍有不同。当CPU执行内核代码时，内核会将stvec指向内核中的汇编代码，具体位置在kernel/kernelvec.S的第12行。因为xv6已经在内核中，kernelvec可以依赖于satp被设置为内核页表，并且栈指针指向一个有效的内核栈。kernelvec将所有32个寄存器都推送到栈上，稍后将它们恢复，以便中断的内核代码可以无干扰地继续执行。


kernelvec将寄存器保存在被中断的内核线程的堆栈上，这是有道理的，因为寄存器值属于该线程。如果陷阱导致切换到不同的线程，这一点尤为重要 - 在这种情况下，陷阱实际上会从新线程的堆栈返回，将被中断的线程的保存的寄存器安全地留在其堆栈上。

kernelvec在保存寄存器后跳转到kerneltrap(kernel/trap.c:135)。kerneltrap准备处理两种类型的陷阱：设备中断和异常。它调用devintr(kernel/trap.c:178)来检查和处理前者。如果陷阱不是设备中断，那么它必须是异常，如果在xv6内核中发生异常，这总是致命错误；内核会调用panic并停止执行。
如果kerneltrap是由于定时器中断而被调用的，而且一个进程的内核线程正在运行(与调度线程不同)，那么kerneltrap会调用yield，以便让其他线程有机会运行。在某个时刻，其中一个线程将会yield，让我们的线程和它的kerneltrap再次恢复执行。第7章解释了yield中发生的事情。

当kerneltrap的工作完成后，它需要返回到被陷阱中断的代码。因为yield可能会影响sepc和sstatus中的前一个模式，所以kerneltrap在开始时保存了它们。现在它恢复这些控制寄存器并返回到kernelvec(kernel/kernelvec.S:50)。kernelvec从堆栈中弹出保存的寄存器并执行sret，将sepc复制到pc并恢复被中断的内核代码。


值得考虑一下如果kerneltrap由于定时器中断而调用yield，陷阱返回会发生什么。

在xv6中，当CPU从用户空间进入内核时，会将CPU的stvec设置为kernelvec，你可以在usertrap(kernel/trap.c:29)中看到这一点。在内核已经开始执行但stvec仍然设置为uservec的时间窗口中，绝不能发生设备中断。幸运的是，RISC-V在开始处理陷阱时总是禁用中断，xv6在设置完stvec之后才重新启用中断，因此在这个关键时刻不会发生设备中断。

### 4.6 pagefault exception
&emsp;Xv6的异常处理相对简单：如果在用户空间发生异常，内核会终止引发异常的进程。如果在内核中发生异常，内核会宕机。而真实的操作系统通常会以更加复杂和有趣的方式响应异常情况。<br>

&emsp;作为一个示例，许多内核使用页面错误来实现写时复制(COW)分叉。为了解释写时复制分叉，考虑xv6的fork，该fork在第3章中有描述。fork导致子进程的初始内存内容与分叉时的父进程相同。Xv6使用uvmcopy(kernel/vm.c:306)来实现fork，它为子进程分配物理内存并将父进程的内存复制到其中。然而，如果子进程和父进程可以共享父进程的物理内存，将更加高效。然而，直接的实现方式将不起作用，因为它会导致父子进程通过对共享堆栈和堆的写入来干扰彼此的执行。,<br>

&emsp;通过适当使用页表权限和页面错误，父进程和子进程可以安全地共享物理内存。当使用一个在页表中没有映射，或者具有PTE_V标志未设置的映射，或者具有禁止正在尝试的操作的权限位(PTE_R、PTE_W、PTE_X、PTE_U)的虚拟地址时，CPU会引发页错误异常。RISC-V区分三种类型的页面错误：加载页面错误(当加载指令无法翻译其虚拟地址时)、存储页面错误(当存储指令无法翻译其虚拟地址时)和指令页面错误(当程序计数器中的地址无法翻译时)。scause寄存器指示页面错误的类型，stval寄存器包含无法翻译的地址。<br>

&emsp;COW(写时复制)分叉的基本计划是，父进程和子进程最初共享所有物理页面，但将它们都映射为只读(PTE_W标志未设置)。父进程和子进程都可以从共享的物理内存中读取数据。如果其中任何一个尝试写入某个页面，RISC-V CPU会引发一个页面错误异常。内核的陷阱处理程序会响应这个异常，分配一个新的物理内存页面，并将引发页面错误的地址映射到的物理页面复制到新分配的页面中。然后，内核会修改引发错误的进程的页表中相关的PTE，将其指向复制的页面并允许读写，然后恢复引发错误的进程执行引发错误的指令。由于PTE允许写入，重新执行的指令现在可以执行而不引发错误。

写时复制需要进行一些记录以帮助确定何时可以释放物理页面，因为每个物理页面可以根据fork、页面错误、exec和exit的使用而被不同数量的页表引用。这种记录允许一个重要的优化：如果一个进程发生了存储页面错误，而且物理页面只被该进程的页表引用，那么就不需要复制。<br>

&emsp;页表和页面错误的组合开辟了广泛的有趣可能性，除了写时复制(COW)分叉之外。另一个广泛使用的功能称为"lazy allocation"，它由两部分组成。
&emsp;首先，在应用程序通过调用sbrk请求更多内存时，内核会记录内存大小的增加，但不会分配物理内存，也不会为新的虚拟地址范围创建页表项(PTEs)。
&emsp;其次，在新地址范围中发生页面错误时，内核会分配一个物理内存页面，并将其映射到页表中。与写时复制分叉一样，内核可以透明地实现懒分配，对应用程序来说是不可见的。
&emsp;因此，懒分配允许应用程序在请求更多内存时，内核不会立即分配物理内存，而是等到应用程序实际使用新地址范围时才进行分配。这可以节省内存资源，提高效率，并允许系统更灵活地管理内存。<br>

&emsp;因为应用程序通常请求比实际需要的内存更多，所以懒分配是一个有益的优化：对于应用程序从未使用的页面，内核无需进行任何工作。此外，如果应用程序要求扩展地址空间很大，那么没有懒分配的情况下使用sbrk会很昂贵：如果一个应用程序请求1GB的内存，那么内核必须分配并清零262,144个4,096字节的页面。懒分配允许这个成本分摊在时间上。

&emsp;然而，懒分配会带来页面错误的额外开销，涉及到内核和用户空间之间的切换。操作系统可以通过在每个页面错误时分配一批连续的页面而不是一个页面，并为这种页面错误专门设计内核入口/退出代码，以减少这种成本。

&emsp;总之，懒分配的优点在于它节省了不必要的内存分配成本，但代价是增加了页面错误的开销。操作系统可以通过一些技巧来减少这种开销，以在性能和资源利用率之间取得平衡。<br>

&emsp;另一个广泛使用的利用页面错误的功能是"需求分页"(demand paging)。在执行(exec)过程中，xv6将应用程序的所有文本和数据都急切地加载到内存中。由于应用程序可能很大，而从磁盘读取数据是昂贵的，这种启动成本可能会让用户感到明显：当用户从shell启动一个大型应用程序时，可能需要很长时间才能看到响应。为了提高响应时间，现代内核会创建用户地址空间的页表，但会将页面的页表项标记为无效。在页面错误发生时，内核会从磁盘上读取页面的内容，并将其映射到用户地址空间中。与写时复制分叉和懒分配一样，内核可以透明地为应用程序实现这一功能。

&emsp;需求分页的优势在于它允许系统在应用程序启动时不必立即加载所有内容，而是根据需要加载，从而减少了启动时间。这使得用户可以更快地看到应用程序的响应，尤其是在启动大型应用程序时。这种技术可以提高系统的资源利用率，并改善用户体验，同时对应用程序来说是透明的，它们不需要自己管理这些细节。<br>

&emsp;运行在计算机上的程序可能需要的内存比计算机的RAM更多。为了优雅地应对这种情况，操作系统可以实现磁盘分页。其基本思想是只将一部分用户页面存储在RAM中，将其余部分存储在磁盘的分页区域中。内核会将对应于存储在分页区域中的内存(因此不在RAM中)的PTE标记为无效。如果应用程序尝试使用已经分页到磁盘上的页面之一，应用程序将发生页面错误，需要将页面分页回RAM：内核陷阱处理程序将分配一个物理RAM页面，从磁盘读取页面并存储到RAM中，并修改相关的PTE以指向RAM。

&emsp;那么如果一个页面需要被分页回RAM，但没有空闲的物理RAM怎么办？在这种情况下，内核必须首先通过将其分页到磁盘或驱逐到磁盘上的分页区域来释放一个物理页面，并将引用该物理页面的PTE标记为无效。驱逐是昂贵的，因此分页最好是不频繁的：如果应用程序仅使用其内存页面的一个子集，且子集的并集适合在RAM中。这种特性通常被称为具有良好的引用局部性。与许多虚拟内存技术一样，内核通常以对应用程序透明的方式实现磁盘分页。

&emsp;在许多情况下，计算机操作在没有或几乎没有空闲物理内存的情况下运行，无论硬件提供了多少RAM。例如，云提供商在一台计算机上多路复用多个客户以高效利用其硬件。另一个例子是用户在智能手机上运行多个应用程序，但物理内存有限。在这种情况下，分配一个页面可能需要首先驱逐一个现有页面。因此，在空闲物理内存稀缺时，分配会变得昂贵。懒分配和需求分页在物理内存稀缺时特别有优势。在sbrk或exec中急切地分配内存会增加额外的驱逐成本以释放内存。此外，存在急切工作被浪费的风险，因为在应用程序使用页面之前，操作系统可能已将其驱逐。

其他结合分页和页面错误异常的功能包括自动扩展堆栈和内存映射文件。<br>


### 4.7 real world
&emsp;trampoline和trampframe可能看起来过于复杂。其背后的一个驱动因素是，RISC-V架构故意在触发陷阱时尽量减少操作，以实现非常快速的trap处理，这事实证明非常重要。因此，内核陷阱处理程序的前几条指令必须在用户环境中执行，使用用户页表和用户寄存器内容。陷阱处理程序最初缺乏有用的信息，例如运行的进程的身份或内核页表的地址。

&emsp;解决这个挑战的方法是，RISC-V提供了受保护的位置，内核可以在进入用户空间之前存储信息，例如sscratch寄存器和指向内核内存但由于缺乏PTE_U权限而受保护的用户页表项。Xv6的跳板和陷阱帧利用了这些RISC-V特性。

&emsp;如果将内核内存映射到每个进程的用户页表中(带有适当的PTE权限标志)，就可以消除特殊的trampoline页面的需求。这也将消除从用户空间陷入内核时的页表切换的需求。这反过来将允许内核中的系统调用实现利用当前进程的用户内存映射，允许内核代码直接引用用户指针。许多操作系统已经使用了这些思想来提高效率。然而，Xv6避免了这些方法，以降低内核因意外使用用户指针而导致的安全漏洞的风险，并减少确保用户和内核虚拟地址不重叠所需的一些复杂性。

&emsp;生产操作系统实现了写时复制分叉、懒分配、需求分页、分页到磁盘、内存映射文件等高级功能。此外，生产操作系统将尝试使用所有的物理内存，无论是用于应用程序还是缓存(例如文件系统的缓冲缓存，在后面的8.2节中将进行介绍)。Xv6在这方面相对简单：您希望您付费购买的物理内存被操作系统充分利用，但Xv6没有这样做。此外，如果Xv6的内存不足，它会向正在运行的应用程序返回错误或终止它，而不是例如驱逐另一个应用程序的页面。<br>


## Chapter 5
&emsp;**中断和设备驱动程序**


&emsp;驱动程序(Driver)是操作系统中用于管理特定设备的代码：它配置设备硬件，告诉设备执行操作，处理产生的中断，并与可能正在等待设备进行输入/输出的进程进行交互。驱动程序的编写可能会很复杂，因为驱动程序与它所管理的设备并发执行。此外，驱动程序必须了解设备的硬件接口，然而硬件接口一般是复杂的，而且文档也很少。<br>
&emsp;通常情况下，需要操作系统处理的设备可以配置为生成中断，这些中断是一种陷阱(trap)类型。内核的陷阱处理代码会识别当设备触发了一个中断，并调用驱动程序的中断处理程序；在xv6中，这个分发过程发生在devintr(kernel/trap.c:178)函数中<br>

&emsp;许多设备驱动程序在两个上下文中执行代码：一个是运行在进程的内核线程中的顶半部分(top half)，另一个是在中断时执行的底半部分(bottom half)。顶半部分通常通过系统调用(例如read和write)被调用，这些系统调用希望设备执行输入/输出操作。这段代码可能会请求硬件启动一个操作(例如，请求磁盘读取一个数据块)，然后等待操作完成。最终，设备完成操作并引发一个中断。驱动程序的中断处理程序充当底半部分，它会确定已完成的操作是什么，如果需要的话唤醒等待的进程，并告诉硬件开始处理任何等待的下一个操作。这种分为顶半部分和底半部分的执行方式有助于提高系统的响应性和并发性。<br>

### 5.1 Code:Console input
&emsp;控制台驱动程序(kernel/console.c)是驱动程序结构的简单示例。控制台驱动程序通过连接到RISC-V的UART串口硬件接受用户输入的字符。控制台驱动程序一次累积一行输入，并处理特殊输入字符，如退格和控制字符u。用户进程，例如shell，使用read系统调用从控制台获取输入行。当您在QEMU中键入xv6的输入时，您的按键通过QEMU模拟的UART硬件传递给xv6。
&emsp;驱动程序所操作的UART硬件是QEMU模拟的16550芯片。在实际计算机上，16550芯片通常用于管理与终端或其他计算机连接的RS232串行链接。在运行QEMU时，它与您的键盘和显示器相连接。
&emsp;UART硬件在软件中显示为一组内存映射的控制寄存器。也就是说，有一些物理地址，RISC-V硬件连接到UART设备，以便加载和存储与设备硬件而不是RAM进行交互。 UART的内存映射地址从0x10000000开始，或称为UART(kernel/memlayout.h:21)。有一些UART控制寄存器，每个都是一个字节宽。它们与UART0的偏移量在(kernel/uart.c:22)中定义。例如，LSR寄存器包含指示是否有待读取的输入字符的位。这些字符(如果有)可以从RHR寄存器中读取。每次读取一个字符时，UART硬件都会将其从等待字符的内部FIFO中删除，并在FIFO为空时清除LSR中的“就绪”位。UART的发送硬件在很大程度上独立于接收硬件；如果软件将一个字节写入THR，UART会发送该字节。

Xv6的主函数在启动时调用consoleinit(kernel/console.c:182)来初始化UART硬件。这段代码配置UART，在每次接收到输入字节时生成接收中断，以及在UART完成发送输出字节时生成传输完成中断(kernel/uart.c:53)。
```c
// kernel/console.c
void
consoleinit(void)
{
  initlock(&cons.lock, "cons");

  uartinit();

  // connect read and write system calls
  // to consoleread and consolewrite.
  devsw[CONSOLE].read = consoleread;
  devsw[CONSOLE].write = consolewrite;
}
// kernel/uart.c
void
uartinit(void)
{
  // disable interrupts.
  WriteReg(IER, 0x00);

  // special mode to set baud rate.
  WriteReg(LCR, LCR_BAUD_LATCH);

  // LSB for baud rate of 38.4K.
  WriteReg(0, 0x03);

  // MSB for baud rate of 38.4K.
  WriteReg(1, 0x00);

  // leave set-baud mode,
  // and set word length to 8 bits, no parity.
  WriteReg(LCR, LCR_EIGHT_BITS);

  // reset and enable FIFOs.
  WriteReg(FCR, FCR_FIFO_ENABLE | FCR_FIFO_CLEAR);

  // enable transmit and receive interrupts.
  WriteReg(IER, IER_TX_ENABLE | IER_RX_ENABLE);

  initlock(&uart_tx_lock, "uart");
}
```

xv6的shell通过由init.c(user/init.c:19)打开的文件描述符从控制台读取数据。对read系统调用的调用通过内核传递到consoleread(kernel/console.c:80)。consoleread等待输入到达(通过中断)，并缓冲到cons.buf中，然后将输入复制到用户空间，并在整行输入完毕后返回给用户进程。如果用户尚未输入完整行，任何正在读取的进程将在sleep调用(kernel/console.c:96)中等待(第7章详细解释了sleep的细节)。

当用户输入字符时，UART硬件要求RISC-V引发中断，这会激活xv6的陷阱处理程序。陷阱处理程序调用devintr(kernel/trap.c:178)，检查RISC-V的scause寄存器以确定中断来自外部设备。然后，它要求一个名为PLIC[3]的硬件单元告诉它哪个设备中断了(kernel/trap.c:187)。如果是UART，devintr将调用uartintr。

uartintr(kernel/uart.c:176)从UART硬件读取任何等待的输入字符，并将它们传递给consoleintr(kernel/console.c:136)。它不会等待字符，因为将来的输入会引发新的中断。consoleintr的工作是在cons.buf中累积输入字符，直到整行到达。consoleintr会特殊处理退格键和一些其他字符。当换行符到达时，consoleintr会唤醒等待的consoleread(如果有的话)。

一旦被唤醒，consoleread将观察到cons.buf中有一整行，将其复制到用户空间，然后(通过系统调用机制)返回到用户空间。
### 5.2 Code:Console output

&emsp;与控制台相关的文件描述符上的写系统调用最终会到达uartputc(kernel/uart.c:87)。设备驱动程序维护一个输出缓冲区(uart_tx_buf)，因此写入进程无需等待UART完成发送；相反，uartputc将每个字符附加到缓冲区，然后调用uartstart来启动设备传输(如果尚未启动)，然后返回。uartputc等待的唯一情况是如果缓冲区已满。

每当UART完成发送一个字节时，它会生成一个中断。uartintr调用uartstart，后者检查设备是否真的已经发送完毕，然后将下一个缓冲的输出字符传递给设备。因此，如果一个进程向控制台写入多个字节，通常第一个字节将由uartputc的调用来启动uartstart发送，其余的缓冲字节将由uartintr中的uartstart调用发送，因为传输完成中断到达。

需要注意的一般模式是通过缓冲和中断将设备活动与进程活动解耦。控制台驱动程序可以处理输入，即使没有进程等待读取它；后续的读取将看到输入。同样，进程可以发送输出而不必等待设备。这种解耦可以通过允许进程与设备I/O并发执行来提高性能，尤其是当设备较慢(如UART)或需要立即响应(如回显键入字符)时，这一点尤为重要。这个想法有时被称为I/O并发。

### 5.3 Concurrency in driver
&emsp;您可能已经注意到consoleread和consoleintr中的acquire调用。这些调用获取锁，用于保护控制台驱动程序的数据结构免受并发访问的影响。这里存在三种并发危险：不同CPU上的两个进程可能同时调用consoleread；硬件可能要求一个CPU在该CPU已经在consoleread内执行时交付控制台(实际上是UART)中断；硬件可能在consoleread执行时在不同的CPU上交付控制台中断。这些危险可能导致竞争条件或死锁。第6章探讨了这些问题以及锁如何解决它们。

在驱动程序中，并发需要特别小心的另一种情况是，一个进程可能正在等待从设备接收输入，但用于信号到达输入的中断可能会在不同的进程(或根本没有进程)正在运行时到达。因此，中断处理程序不允许考虑它们中断的进程或代码。例如，中断处理程序不能安全地使用当前进程的页表来调用copyout。中断处理程序通常执行相对较少的工作(例如，只是将输入数据复制到缓冲区)，然后唤醒顶层代码来完成其余的工作。

### 5.4 Timer interrupts
&emsp;xv6使用定时器中断来维护其时钟，并使其能够在计算密集型进程之间切换；在usertrap和kerneltrap中的yield调用导致了这种切换。定时器中断来自连接到每个RISC-V CPU的时钟硬件。xv6对这些时钟硬件进行编程，以便它们定期中断每个CPU。

RISC-V要求定时器中断在机器模式下执行，而不是在监管模式下执行。RISC-V机器模式在没有分页的情况下执行，并带有一组单独的控制寄存器，因此在机器模式下运行普通的xv6内核代码并不可行。因此，xv6将定时器中断完全与上述陷阱机制分开处理。

在start.c中以机器模式执行的代码，在main函数之前，用于设置接收定时器中断(kernel/start.c:63)。这个工作的一部分是编程CLINT硬件(核本地中断器)，以在一定延迟后生成中断。另一部分是设置一个与trapframe类似的临时区域，以帮助定时器中断处理程序保存寄存器和CLINT寄存器的地址。最后，start将mtvec设置为timervec并启用定时器中断。

定时器中断可以在用户或内核代码执行的任何时刻发生；内核无法在关键操作期间禁用定时器中断。因此，定时器中断处理程序必须以一种不会干扰被中断的内核代码的方式执行其工作。基本策略是要求RISC-V引发一个“软中断”并立即返回。RISC-V使用普通的陷阱机制将软中断传递给内核，并允许内核禁用它们。处理由定时器中断生成的软中断的代码可以在devintr(kernel/trap.c:205)中看到。

机器模式的定时器中断处理程序是timervec(kernel/kernelvec.S:95)。它保存了start准备的临时区域中的一些寄存器，告诉CLINT何时生成下一个定时器中断，请求RISC-V引发软中断，然后恢复寄存器并返回。定时器中断处理程序中没有C代码。

### 5.5 Real world
xv6允许在内核执行时以及在执行用户程序时发生设备和定时器中断。即使在内核执行期间，定时器中断也会强制进行线程切换(调用yield)。在内核线程之间公平地切片CPU的能力在内核线程有时需要花费大量计算时间而不返回到用户空间时非常有用。然而，内核代码需要注意，它可能会被挂起(由于定时器中断)并稍后在不同的CPU上恢复，这是xv6中一些复杂性的源泉(参见第6.6节)。如果设备和定时器中断仅在执行用户代码时发生，内核可以更简单一些。

支持典型计算机上的所有设备以其全部功能是一项繁重的工作，因为有很多设备，这些设备有许多功能，设备和驱动程序之间的协议可能复杂且文档不完善。在许多操作系统中，驱动程序的代码量比核心内核还要多。

UART驱动程序通过读取UART控制寄存器一次检索一个字节的数据；这种模式称为编程I/O，因为软件驱动数据传输。编程I/O很简单，但在高数据速率下使用起来太慢。需要以高速移动大量数据的设备通常使用直接内存访问(DMA)。DMA设备硬件直接将传入数据写入RAM，并从RAM中读取传出数据。现代磁盘和网络设备使用DMA。DMA设备的驱动程序将在RAM中准备数据，然后使用对控制寄存器的单个写入来告诉设备处理准备好的数据。

中断在设备需要在不可预测的时间、而且不太频繁地引起注意时是有意义的。但中断会产生高的CPU开销。因此，高速设备(如网络和磁盘控制器)使用减少中断需求的技巧。一个技巧是为整个一批传入或传出请求引发单个中断。另一个技巧是将中断完全禁用，并定期检查设备是否需要处理。这种技术称为轮询。轮询在设备执行操作非常快速的情况下是有意义的，但如果设备大部分时间处于空闲状态，它会浪费CPU时间。一些驱动程序根据当前设备负载动态切换在轮询和中断之间。

UART驱动程序首先将传入数据复制到内核中的缓冲区，然后复制到用户空间。这在低数据速率下是有意义的，但这样的双重复制会显著降低对于生成或消耗数据非常快的设备的性能。一些操作系统能够在用户空间缓冲区和设备硬件之间直接传递数据，通常使用DMA。

如第1章所述，控制台对应用程序来说表现为常规文件，应用程序使用read和write系统调用读取输入和写入输出。应用程序可能希望控制设备的一些方面，这不能通过标准的文件系统调用来表达(例如，在控制台驱动程序中启用/禁用行缓冲)。Unix操作系统支持ioctl系统调用用于处理这种情况。

某些计算机使用需要系统必须在有界时间内做出响应。例如，在安全关键系统中，错过截止日期可能会导致灾难。Xv6不适用于硬实时环境。用于硬实时的操作系统往往是与应用程序链接的库，以允许进行最坏情况响应时间分析。Xv6也不适用于软实时应用程序，因为偶尔错过截止日期是可以接受的，因为xv6的调度程序过于简单，它有内核代码路径，在此路径中中断被禁用了很长时间。


